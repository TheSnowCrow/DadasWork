<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Magic Typing!</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        html,
        body {
            overflow: hidden;
            touch-action: none;
            height: 100%;
            width: 100%;
            position: fixed;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
        }

        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #text-display {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 25vh;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.8) 0%, rgba(0, 0, 0, 0.4) 60%, transparent 100%);
            padding: 10px;
        }

        #typed-text {
            font-size: clamp(32px, 10vw, 120px);
            font-weight: bold;
            text-align: center;
            color: #fff;
            text-shadow:
                0 0 20px #ff00ff,
                0 0 40px #ff00ff,
                0 0 60px #ff00ff,
                3px 3px 0 #00ffff;
            word-wrap: break-word;
            max-width: 95%;
            line-height: 1.2;
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from {
                text-shadow:
                    0 0 20px #ff00ff,
                    0 0 40px #ff00ff,
                    0 0 60px #ff00ff,
                    3px 3px 0 #00ffff;
            }

            to {
                text-shadow:
                    0 0 30px #00ffff,
                    0 0 50px #00ffff,
                    0 0 70px #00ffff,
                    3px 3px 0 #ff00ff;
            }
        }

        #mode-buttons {
            position: fixed;
            top: 8px;
            left: 0;
            right: 0;
            z-index: 20;
            display: flex;
            gap: 3px;
            justify-content: center;
            padding: 0 5px;
            flex-wrap: nowrap;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
        }

        #mode-buttons::-webkit-scrollbar {
            display: none;
        }

        .action-btn,
        .mode-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            padding: 5px 7px;
            color: white;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
            -webkit-user-select: none;
            user-select: none;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .mode-btn:hover,
        .mode-btn:active,
        .action-btn:hover,
        .action-btn:active {
            background: rgba(255, 255, 255, 0.35);
        }

        .mode-btn.active {
            background: rgba(255, 255, 255, 0.4);
            border-color: rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }

        .letter-pop {
            display: inline-block;
            animation: pop 0.3s ease-out;
        }

        @keyframes pop {
            0% {
                transform: scale(0);
                opacity: 0;
            }

            50% {
                transform: scale(1.3);
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        /* Hidden text input for mobile keyboard */
        #mobile-input {
            position: fixed;
            top: -100px;
            left: 0;
            width: 1px;
            height: 1px;
            opacity: 0;
        }

        /* Controls positioned in the bottom right corner */
        .controls-bottom-right {
            position: fixed;
            bottom: 10px;
            right: 10px;
            z-index: 25;
            display: flex;
            gap: 5px;
        }

        #keyboard-toggle {
            background: rgba(100, 100, 255, 0.25);
        }

        #keyboard-toggle:active {
            background: rgba(100, 100, 255, 0.4);
        }

        #reset-btn {
            background: rgba(255, 80, 80, 0.25);
            color: rgba(255, 255, 255, 0.9);
        }

        #reset-btn:active {
            background: rgba(255, 80, 80, 0.4);
        }

        #free-text-toggle {
            background: rgba(80, 255, 80, 0.25);
        }

        #free-text-toggle:active {
            background: rgba(80, 255, 80, 0.4);
        }


        /* Trace letter overlay for both modes */
        #trace-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 15;
            pointer-events: none;
        }

        #trace-letter {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -60%);
            font-size: 50vw;
            font-weight: bold;
            color: transparent;
            /* Default non-active state */
            -webkit-text-stroke: 3px rgba(255, 255, 255, 0.25);
            text-stroke: 3px rgba(255, 255, 255, 0.25);
            pointer-events: none;
            font-family: Arial, sans-serif;
            transition: all 0.1s ease-in-out;
        }

        /* Flash effect for correct key presses on desktop */
        #trace-letter.flash {
            -webkit-text-stroke: 5px white;
            text-stroke: 5px white;
            color: yellow;
            text-shadow: 0 0 20px yellow, 0 0 40px orange;
            transform: translate(-50%, -60%) scale(1.05);
        }

        #trace-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 16;
            display: none;
            /* Controlled by JS based on isMobile */
        }

        #trace-hint {
            position: fixed;
            top: 45px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.5);
            font-size: 14px;
            z-index: 17;
            display: none;
            /* Controlled by JS based on isMobile */
            text-align: center;
        }

        @media (min-width: 700px) {

            .mode-btn,
            .action-btn {
                padding: 6px 12px;
                font-size: 13px;
                border-radius: 15px;
            }

            #mode-buttons {
                gap: 6px;
                top: 12px;
            }

            #typed-text {
                font-size: clamp(48px, 12vw, 150px);
            }

            #trace-letter {
                font-size: 40vw;
                -webkit-text-stroke: 4px rgba(255, 255, 255, 0.25);
            }

            #trace-letter.flash {
                -webkit-text-stroke: 6px white;
                text-stroke: 6px white;
            }
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>
    <input type="text" id="mobile-input" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"
        aria-label="Type here">

    <div id="mode-buttons">
        <button class="mode-btn active" data-mode="1">Waves</button>
        <button class="mode-btn" data-mode="2">Stars</button>
        <button class="mode-btn" data-mode="3">Bubbles</button>
        <button class="mode-btn" data-mode="4">Fire</button>
        <button class="mode-btn" data-mode="5">Spiral</button>
        <button class="mode-btn" data-mode="6">Pipes</button>
        <button class="mode-btn" data-mode="7">Matrix</button>
        <button class="mode-btn" data-mode="8">DVD</button>
        <button class="mode-btn" data-mode="9">Fireworks</button>
        <button class="mode-btn" data-mode="10">Worms</button>
        <button class="mode-btn" data-mode="11">Ocean</button>
        <button class="mode-btn" data-mode="12">Garden</button>
        <button class="mode-btn" data-mode="13">Rockets</button>
        <button class="mode-btn" data-mode="14">Music</button>
        <button class="mode-btn" data-mode="15">Weather</button>
        <button class="mode-btn" data-mode="16">Kaleidoscope</button>
        <button class="mode-btn" data-mode="17">Swarm</button>
    </div>

    <div id="trace-overlay">
        <div id="trace-letter">A</div>
    </div>
    <canvas id="trace-canvas"></canvas>
    <div id="trace-hint">Trace the letter with your finger!</div>

    <div class="controls-bottom-right">
        <!-- These buttons visibility is controlled by JS -->
        <button id="reset-btn" class="action-btn" style="display: none;">Reset</button>
        <button id="free-text-toggle" class="action-btn" style="display: none;">Free Type</button>
        <button id="keyboard-toggle" class="action-btn" style="display: none;">Keyboard</button>
    </div>

    <div id="text-display">
        <div id="typed-text"></div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const textDisplay = document.getElementById('typed-text');
        const modeButtons = document.querySelectorAll('.mode-btn');
        const mobileInput = document.getElementById('mobile-input');

        // Control buttons
        const resetBtn = document.getElementById('reset-btn');
        const keyboardToggle = document.getElementById('keyboard-toggle');
        const freeTextToggle = document.getElementById('free-text-toggle');

        const traceOverlay = document.getElementById('trace-overlay');
        const traceLetter = document.getElementById('trace-letter');
        const traceCanvas = document.getElementById('trace-canvas');
        const traceHint = document.getElementById('trace-hint');
        const traceCtx = traceCanvas.getContext('2d');

        // Analysis canvas for checking fill percentage (scaled down for performance)
        const hitCanvas = document.createElement('canvas');
        const hitCtx = hitCanvas.getContext('2d');
        const checkCanvas = document.createElement('canvas');
        const checkCtx = checkCanvas.getContext('2d');
        const SCALE_FACTOR = 0.2; // Analyze at 20% resolution

        let width, height;
        let time = 0;
        let typedString = '';
        let energy = 0;
        let targetEnergy = 0;
        let hueBase = 0;
        let particles = [];
        let currentMode = 1;
        let isMobile = false;
        let keyboardVisible = false;
        let isChallengeMode = true; // NEW: Controls desktop behavior

        // Tracing/Typing variables
        let isTracing = false;
        let lastTraceX = 0;
        let lastTraceY = 0;
        let currentTraceLetter = 'A'; // The target letter to trace or type

        // Expanded to include both cases and numbers
        const traceLetters = 'AaBbCcDdEeFfGfHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz0123456789'.split('');
        let shuffledLetters = [];
        let letterIndex = 0;
        let totalLetterPixels = 0; // Number of pixels in the target letter

        // --- Core Game Logic ---

        function shuffleLetters() {
            shuffledLetters = [...traceLetters].sort(() => Math.random() - 0.5);
            // Always start with "I LOVE YOU"
            const startSequence = ['I', 'L', 'O', 'V', 'E', 'Y', 'O', 'U'];
            shuffledLetters = [...startSequence, ...shuffledLetters];
            letterIndex = 0;
        }

        function getNextLetter() {
            if (letterIndex >= shuffledLetters.length) {
                shuffleLetters();
            }
            return shuffledLetters[letterIndex++];
        }

        // --- Tracing Analysis (Mobile Only) ---

        function prepareTraceAnalysis() {
            if (!isMobile) return;

            // Set analysis canvas sizes
            hitCanvas.width = width * SCALE_FACTOR;
            hitCanvas.height = height * SCALE_FACTOR;
            checkCanvas.width = width * SCALE_FACTOR;
            checkCanvas.height = height * SCALE_FACTOR;

            // Clear hit canvas
            hitCtx.clearRect(0, 0, hitCanvas.width, hitCanvas.height);

            // Draw the target letter (always uppercase for analysis mask) onto hitCanvas
            const fontSize = (window.innerWidth >= 700 ? 40 : 50) * (width / 100);
            hitCtx.font = `bold ${fontSize * SCALE_FACTOR}px Arial, sans-serif`;
            hitCtx.fillStyle = 'red';
            hitCtx.textAlign = 'center';
            hitCtx.textBaseline = 'middle';

            const x = hitCanvas.width / 2;
            const y = hitCanvas.height * 0.45;

            // Use the actual letter (preserving case) for the tracing shape
            hitCtx.fillText(currentTraceLetter, x, y);

            // Count target pixels
            const imgData = hitCtx.getImageData(0, 0, hitCanvas.width, hitCanvas.height);
            const data = imgData.data;
            totalLetterPixels = 0;
            // Iterate alpha channel (every 4th byte)
            for (let i = 3; i < data.length; i += 4) {
                if (data[i] > 100) { // If pixel is somewhat opaque
                    totalLetterPixels++;
                }
            }
        }

        function checkTraceProgress() {
            if (totalLetterPixels === 0 || !isMobile) return 0;

            // Draw current trace onto checkCanvas
            checkCtx.clearRect(0, 0, checkCanvas.width, checkCanvas.height);
            checkCtx.drawImage(traceCanvas, 0, 0, checkCanvas.width, checkCanvas.height);

            const hitData = hitCtx.getImageData(0, 0, hitCanvas.width, hitCanvas.height).data;
            const checkData = checkCtx.getImageData(0, 0, checkCanvas.width, checkCanvas.height).data;

            let coveredPixels = 0;

            // Check intersection
            for (let i = 3; i < hitData.length; i += 4) {
                // If this pixel is part of the letter (in hitData) 
                // AND it has been painted by user (in checkData)
                if (hitData[i] > 100 && checkData[i] > 50) {
                    coveredPixels++;
                }
            }

            return coveredPixels / totalLetterPixels;
        }

        // --- UI & State Management ---

        function flashLetter() {
            traceLetter.classList.add('flash');
            // Remove flash state after a short delay
            setTimeout(() => {
                traceLetter.classList.remove('flash');
            }, 150);
        }

        function showNextTraceLetter() {
            currentTraceLetter = getNextLetter();
            traceLetter.textContent = currentTraceLetter;

            // Only clear and prepare analysis if we are in tracing mode or challenge mode
            if (isMobile || isChallengeMode) {
                traceCtx.clearRect(0, 0, traceCanvas.width, traceCanvas.height);
                requestAnimationFrame(prepareTraceAnalysis);
            }

            // Show/Hide letter based on mode
            traceOverlay.style.display = (isMobile || isChallengeMode) ? 'block' : 'none';
        }

        function spawnParticles(char, x = Math.random() * width, y = Math.random() * height * 0.5) {
            const charCode = char.toUpperCase().charCodeAt(0);
            const hue = (charCode * 15 + hueBase) % 360;
            for (let i = 0; i < 5; i++) {
                particles.push(new Particle(x, y, hue + Math.random() * 40 - 20));
            }
        }

        function updateText(char) {
            if (char === 'Backspace') typedString = typedString.slice(0, -1);
            else if (char === ' ') typedString += ' ';
            else if (char.length === 1) {
                typedString += char;
                targetEnergy = Math.min(1, targetEnergy + 0.15);
                hueBase = (hueBase + char.toUpperCase().charCodeAt(0) * 3) % 360;
                spawnParticles(char);
            }
            const displayText = typedString.slice(-20);
            textDisplay.innerHTML = displayText.split('').map((letter, i) => letter === ' ' ? ' ' : `<span class="letter-pop" style="animation-delay: ${i * 0.02}s">${letter}</span>`).join('');
        }

        function setMode(mode) {
            currentMode = mode;
            modeButtons.forEach(btn => btn.classList.toggle('active', parseInt(btn.dataset.mode) === mode));
            ctx.fillStyle = '#000'; ctx.fillRect(0, 0, width, height);
            if (mode === 2) initStars(); if (mode === 3) initBubbles(); if (mode === 6) initPipes(); if (mode === 7) initMatrix(); if (mode === 8) initDVD(); if (mode === 10) initWorms();
            if (mode === 11) initOcean(); if (mode === 12) initGarden(); if (mode === 13) initRockets(); if (mode === 14) initMusic(); if (mode === 15) initWeather(); if (mode === 17) initSwarm();
            fireParticles = []; fireworks = []; fireworkParticles = [];
        }

        function toggleChallengeMode() {
            isChallengeMode = !isChallengeMode;
            freeTextToggle.textContent = isChallengeMode ? 'Free Type' : 'Challenge';
            showNextTraceLetter(); // Updates the visibility of the letter overlay
            // Clear text when switching modes for clarity
            typedString = '';
            textDisplay.innerHTML = '';
            targetEnergy = 0.5;
        }

        // --- Keyboard Input (Desktop & Mobile fallback) ---

        function handleDesktopKeydown(e) {
            // Prevent default for space to stop page scrolling
            if (e.key === ' ') e.preventDefault();

            // Ignore system keys
            if (e.key === 'Shift' || e.key === 'Control' || e.key === 'Alt' || e.key === 'Meta') return;

            // Check if it's a valid character (letter, number, or space)
            const isCharacter = e.key.length === 1 && (/[a-zA-Z0-9 ]/).test(e.key);

            if (isCharacter) {
                // Universal effect (reward for any key press)
                targetEnergy = Math.min(1, targetEnergy + 0.05);
                if (e.key !== ' ') {
                    spawnParticles(e.key);
                }

                if (isChallengeMode) {
                    // Challenge Mode: Check for correct key match
                    if (e.key.toUpperCase() === currentTraceLetter.toUpperCase()) {
                        e.preventDefault(); // Stop the character from being processed by normal input

                        flashLetter();

                        // Add the character as typed (respecting case, though the challenge is case-insensitive)
                        updateText(e.key);

                        // Move to the next letter
                        setTimeout(() => showNextTraceLetter(), 300);
                    }
                } else {
                    // Free Text Mode: Accept any character
                    updateText(e.key);
                }
            } else if (e.key === 'Backspace') {
                updateText('Backspace');
            }
        }

        // --- Setup & Initialization ---

        function detectMobile() {
            // Check for touch capability
            isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            setupInputMode();
        }

        function setupInputMode() {
            // Hide all special controls first
            resetBtn.style.display = 'none';
            keyboardToggle.style.display = 'none';
            freeTextToggle.style.display = 'none';

            if (isMobile) {
                // MOBILE: Enable Tracing UI and Input
                traceCanvas.style.display = 'block';
                traceHint.style.display = 'block';
                traceOverlay.style.display = 'block';
                keyboardToggle.style.display = 'inline-block';
                resetBtn.style.display = 'inline-block';

                // Tracing logic is active for mobile
            } else {
                // DESKTOP: Disable Tracing UI, Enable Keyboard Challenge UI & Controls
                traceCanvas.style.display = 'none';
                traceHint.style.display = 'none';

                // Show desktop controls
                resetBtn.style.display = 'inline-block';
                freeTextToggle.style.display = 'inline-block';

                // Ensure challenge mode starts enabled for desktop
                isChallengeMode = true;
                freeTextToggle.textContent = 'Free Type';

                showNextTraceLetter(); // Show the first letter

                // Set up the universal keydown listener for the challenge mode
                document.removeEventListener('keydown', handleDesktopKeydown); // Prevent duplicates
                document.addEventListener('keydown', handleDesktopKeydown);
            }
        }

        // --- Particle Class (Unchanged) ---

        class Particle {
            constructor(x, y, hue, config = {}) {
                this.x = x; this.y = y; this.hue = hue;
                this.size = config.size || Math.random() * 30 + 20;
                this.speedX = config.speedX || (Math.random() - 0.5) * 8;
                this.speedY = config.speedY || (Math.random() - 0.5) * 8 - 3;
                this.life = 1; this.decay = config.decay || 0.008 + Math.random() * 0.008;
                this.gravity = config.gravity || 0.05;
            }
            update() {
                this.x += this.speedX; this.y += this.speedY; this.speedY += this.gravity;
                this.life -= this.decay; this.size *= 0.99;
            }
            draw() {
                ctx.beginPath();
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);
                gradient.addColorStop(0, `hsla(${this.hue}, 100%, 70%, ${this.life * 0.8})`);
                gradient.addColorStop(0.5, `hsla(${this.hue + 30}, 100%, 50%, ${this.life * 0.4})`);
                gradient.addColorStop(1, `hsla(${this.hue}, 100%, 50%, 0)`);
                ctx.fillStyle = gradient;
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // --- Visualization Modes (Content Unchanged) ---

        // MODE 1: OCEAN WAVES
        function drawOceanWaves() {
            const bgGrad = ctx.createLinearGradient(0, 0, 0, height);
            const hue1 = (time * 5) % 360;
            bgGrad.addColorStop(0, `hsl(${(hue1 + 200) % 360}, 60%, 8%)`);
            bgGrad.addColorStop(0.5, `hsl(${(hue1 + 220) % 360}, 50%, 12%)`);
            bgGrad.addColorStop(1, `hsl(${(hue1 + 240) % 360}, 60%, 6%)`);
            ctx.fillStyle = bgGrad;
            ctx.fillRect(0, 0, width, height);

            for (let layer = 0; layer < 3; layer++) {
                ctx.beginPath();
                const auroraY = height * 0.15;
                const points = [];
                const baseSpeed = 0.2 + energy * 0.5;
                for (let i = 0; i <= 80; i++) {
                    const x = (i / 80) * width;
                    const waviness = Math.sin(i * 0.1 + time * baseSpeed + layer) * 30 +
                        Math.sin(i * 0.05 + time * baseSpeed * 0.6) * 50 +
                        energy * Math.sin(i * 0.2 + time) * 40;
                    points.push({ x, y: auroraY + layer * 40 + waviness });
                }
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length - 1; i++) {
                    const xc = (points[i].x + points[i + 1].x) / 2;
                    const yc = (points[i].y + points[i + 1].y) / 2;
                    ctx.quadraticCurveTo(points[i].x, points[i].y, xc, yc);
                }
                ctx.lineTo(width, height * 0.5);
                ctx.lineTo(0, height * 0.5);
                ctx.closePath();
                const hue = (time * 8 + layer * 60 + 120) % 360;
                const gradient = ctx.createLinearGradient(0, auroraY - 50, 0, height * 0.5);
                gradient.addColorStop(0, `hsla(${hue}, 80%, 60%, ${0.15 + energy * 0.1})`);
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.fill();
            }

            const waveCount = Math.floor(3 + energy * 5);
            for (let w = 0; w < waveCount; w++) {
                ctx.beginPath();
                const hue = (time * 10 + w * 40) % 360;
                const yOffset = height * 0.35 + w * 50;
                const amplitude = 20 + energy * 60 + w * 10;
                const frequency = 0.003 + w * 0.001;
                const speed = (0.2 + energy * 0.5) + w * 0.1;
                ctx.moveTo(0, yOffset);
                for (let x = 0; x <= width; x += 3) {
                    const y = yOffset + Math.sin(x * frequency + time * speed) * amplitude +
                        Math.sin(x * frequency * 2.5 + time * speed * 1.5) * amplitude * 0.5;
                    ctx.lineTo(x, y);
                }
                ctx.lineTo(width, height);
                ctx.lineTo(0, height);
                ctx.closePath();
                const gradient = ctx.createLinearGradient(0, yOffset - amplitude, 0, height);
                gradient.addColorStop(0, `hsla(${hue}, 80%, 50%, ${0.3 - w * 0.04})`);
                gradient.addColorStop(1, `hsla(${hue + 60}, 60%, 20%, 0.1)`);
                ctx.fillStyle = gradient;
                ctx.fill();
            }

            for (let i = 0; i < 3 + energy * 5; i++) {
                const orbSpeed = 0.15 + energy * 0.3;
                const x = width * 0.5 + Math.sin(time * orbSpeed + i * 1.3) * (200 + energy * 100);
                const y = height * 0.35 + Math.cos(time * orbSpeed * 1.3 + i * 1.7) * (100 + energy * 50);
                const size = 30 + Math.sin(time * 0.5 + i) * 20 + energy * 30;
                const hue = (time * 15 + i * 50) % 360;
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, size);
                gradient.addColorStop(0, `hsla(${hue}, 100%, 80%, 0.8)`);
                gradient.addColorStop(0.5, `hsla(${hue + 20}, 100%, 60%, 0.3)`);
                gradient.addColorStop(1, `hsla(${hue}, 80%, 30%, 0)`);
                ctx.beginPath(); ctx.fillStyle = gradient; ctx.arc(x, y, size, 0, Math.PI * 2); ctx.fill();
            }
        }

        // MODE 2: STARFIELD
        let stars = [];
        function initStars() {
            stars = [];
            for (let i = 0; i < 300; i++) {
                stars.push({
                    x: Math.random() * width - width / 2,
                    y: Math.random() * height - height / 2,
                    z: Math.random() * 1000,
                    size: Math.random() * 2 + 0.5
                });
            }
        }

        function drawStarfield() {
            ctx.fillStyle = '#000010';
            ctx.fillRect(0, 0, width, height);
            for (let i = 0; i < 3; i++) {
                const nebulaSpeed = 0.05 + energy * 0.1;
                const x = width * 0.3 + Math.sin(time * nebulaSpeed + i * 2) * width * 0.3;
                const y = height * 0.3 + Math.cos(time * nebulaSpeed * 1.5 + i * 2) * height * 0.2;
                const size = 200 + energy * 150 + Math.sin(time * 0.5 + i) * 50;
                const hue = (hueBase + i * 80) % 360;
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, size);
                gradient.addColorStop(0, `hsla(${hue}, 80%, 50%, ${0.15 + energy * 0.1})`);
                gradient.addColorStop(0.5, `hsla(${hue + 40}, 70%, 30%, 0.08)`);
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, width, height);
            }
            const speed = 0.5 + energy * 15;
            const centerX = width / 2, centerY = height / 2;
            stars.forEach(star => {
                star.z -= speed;
                if (star.z <= 0) { star.z = 1000; star.x = Math.random() * width - width / 2; star.y = Math.random() * height - height / 2; }
                const sx = (star.x / star.z) * 500 + centerX, sy = (star.y / star.z) * 500 + centerY;
                const size = (1 - star.z / 1000) * 4 * star.size;
                if (sx >= 0 && sx <= width && sy >= 0 && sy <= height) {
                    const brightness = 1 - star.z / 1000;
                    const hue = (hueBase + star.z * 0.1) % 360;
                    const prevZ = star.z + speed;
                    const psx = (star.x / prevZ) * 500 + centerX, psy = (star.y / prevZ) * 500 + centerY;
                    ctx.beginPath(); ctx.strokeStyle = `hsla(${hue}, 80%, 80%, ${brightness * 0.5})`; ctx.lineWidth = size * 0.5;
                    ctx.moveTo(psx, psy); ctx.lineTo(sx, sy); ctx.stroke();
                    ctx.beginPath(); ctx.fillStyle = `hsla(${hue}, 60%, 90%, ${brightness})`; ctx.arc(sx, sy, size, 0, Math.PI * 2); ctx.fill();
                }
            });
        }

        // MODE 3: BUBBLES
        let bubbles = [];
        function initBubbles() { bubbles = []; for (let i = 0; i < 30; i++) bubbles.push(createBubble()); }
        function createBubble() { return { x: Math.random() * width, y: height + Math.random() * 100, size: Math.random() * 60 + 20, speed: Math.random() * 0.3 + 0.2, wobble: Math.random() * Math.PI * 2, wobbleSpeed: Math.random() * 0.01 + 0.005, hue: Math.random() * 360 }; }

        function drawBubbles() {
            const bgGrad = ctx.createLinearGradient(0, 0, 0, height);
            const hue1 = (hueBase + 180) % 360;
            bgGrad.addColorStop(0, `hsl(${hue1}, 50%, 15%)`); bgGrad.addColorStop(1, `hsl(${(hue1 + 40) % 360}, 60%, 8%)`);
            ctx.fillStyle = bgGrad; ctx.fillRect(0, 0, width, height);
            for (let i = 0; i < 5; i++) {
                const causticSpeed = 0.2 + energy * 0.4;
                const x = width * 0.5 + Math.sin(time * causticSpeed + i) * width * 0.4;
                const y = height * 0.3 + Math.cos(time * causticSpeed * 0.8 + i * 1.5) * height * 0.2;
                const size = 150 + Math.sin(time + i) * 50;
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, size);
                gradient.addColorStop(0, `hsla(${(hueBase + 180) % 360}, 60%, 70%, 0.1)`); gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient; ctx.fillRect(0, 0, width, height);
            }
            const speedMultiplier = 0.5 + energy * 3;
            bubbles.forEach(bubble => {
                bubble.y -= bubble.speed * speedMultiplier; bubble.wobble += bubble.wobbleSpeed * (1 + energy * 2); bubble.x += Math.sin(bubble.wobble) * 1;
                if (bubble.y < -bubble.size * 2) { Object.assign(bubble, createBubble()); bubble.hue = hueBase + Math.random() * 60; }
                const gradient = ctx.createRadialGradient(bubble.x - bubble.size * 0.3, bubble.y - bubble.size * 0.3, 0, bubble.x, bubble.y, bubble.size);
                const hue = (bubble.hue + time * 5) % 360;
                gradient.addColorStop(0, `hsla(${hue}, 80%, 90%, 0.4)`); gradient.addColorStop(0.5, `hsla(${hue}, 70%, 60%, 0.2)`); gradient.addColorStop(1, `hsla(${hue}, 50%, 40%, 0.05)`);
                ctx.beginPath(); ctx.fillStyle = gradient; ctx.arc(bubble.x, bubble.y, bubble.size, 0, Math.PI * 2); ctx.fill();
                const highlightGrad = ctx.createRadialGradient(bubble.x - bubble.size * 0.4, bubble.y - bubble.size * 0.4, 0, bubble.x - bubble.size * 0.3, bubble.y - bubble.size * 0.3, bubble.size * 0.4);
                highlightGrad.addColorStop(0, 'rgba(255,255,255,0.8)'); highlightGrad.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.beginPath(); ctx.fillStyle = highlightGrad; ctx.arc(bubble.x - bubble.size * 0.3, bubble.y - bubble.size * 0.3, bubble.size * 0.35, 0, Math.PI * 2); ctx.fill();
            });
            if (energy > 0.3 && bubbles.length < 60) bubbles.push(createBubble());
        }

        // MODE 4: FIRE
        let fireParticles = [];
        function drawFire() {
            ctx.fillStyle = 'rgba(10, 5, 0, 0.3)'; ctx.fillRect(0, 0, width, height);
            const spawnRate = 1 + energy * 12;
            for (let i = 0; i < spawnRate; i++) {
                const x = width * 0.5 + (Math.random() - 0.5) * (150 + energy * 350);
                fireParticles.push({ x: x, y: height * 0.65, vx: (Math.random() - 0.5) * 1.5, vy: -Math.random() * 1.5 - 1 - energy * 4, size: Math.random() * 30 + 15 + energy * 35, life: 1, decay: 0.008 + Math.random() * 0.008 });
            }
            fireParticles = fireParticles.filter(p => p.life > 0);
            fireParticles.forEach(p => {
                p.x += p.vx + Math.sin(time * 5 + p.y * 0.05) * 0.3; p.y += p.vy; p.vy *= 0.99; p.life -= p.decay; p.size *= 0.98;
                let hue, lightness;
                if (p.life > 0.7) { hue = 45 + (hueBase * 0.1); lightness = 70 + (p.life - 0.7) * 100; }
                else if (p.life > 0.4) { hue = 30 + (hueBase * 0.1); lightness = 50; }
                else { hue = 10 + (hueBase * 0.1); lightness = 30 + p.life * 30; }
                const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size);
                gradient.addColorStop(0, `hsla(${hue}, 100%, ${lightness}%, ${p.life})`); gradient.addColorStop(0.4, `hsla(${hue - 15}, 100%, ${lightness * 0.7}%, ${p.life * 0.6})`); gradient.addColorStop(1, 'transparent');
                ctx.beginPath(); ctx.fillStyle = gradient; ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill();
            });
            const baseGlow = ctx.createRadialGradient(width / 2, height * 0.7, 0, width / 2, height * 0.7, 200 + energy * 250);
            baseGlow.addColorStop(0, `hsla(${30 + hueBase * 0.1}, 100%, 50%, ${0.2 + energy * 0.2})`); baseGlow.addColorStop(0.5, `hsla(${15 + hueBase * 0.1}, 100%, 30%, 0.1)`); baseGlow.addColorStop(1, 'transparent');
            ctx.fillStyle = baseGlow; ctx.fillRect(0, 0, width, height);
        }

        // MODE 5: RAINBOW SPIRAL
        function drawRainbowSpiral() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)'; ctx.fillRect(0, 0, width, height);
            const centerX = width / 2, centerY = height / 2, maxRadius = Math.min(width, height) * 0.45;
            const arms = 4 + Math.floor(energy * 4), rotationSpeed = time * (0.2 + energy * 0.8);
            for (let arm = 0; arm < arms; arm++) {
                const armOffset = (arm / arms) * Math.PI * 2;
                ctx.beginPath();
                for (let i = 0; i < 200; i++) {
                    const t = i / 200, angle = t * Math.PI * 6 + armOffset + rotationSpeed, radius = t * maxRadius * (0.7 + energy * 0.5);
                    const x = centerX + Math.cos(angle) * radius, y = centerY + Math.sin(angle) * radius;
                    if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                }
                const hue = (hueBase + arm * (360 / arms) + time * 25) % 360;
                ctx.strokeStyle = `hsla(${hue}, 100%, 60%, ${0.5 + energy * 0.4})`; ctx.lineWidth = 2 + energy * 6; ctx.lineCap = 'round'; ctx.stroke();
            }
            const centerGlow = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 80 + energy * 120);
            centerGlow.addColorStop(0, `hsla(${hueBase}, 100%, 90%, ${0.6 + energy * 0.4})`); centerGlow.addColorStop(0.3, `hsla(${(hueBase + 60) % 360}, 100%, 60%, 0.3)`); centerGlow.addColorStop(1, 'transparent');
            ctx.fillStyle = centerGlow; ctx.beginPath(); ctx.arc(centerX, centerY, 80 + energy * 120, 0, Math.PI * 2); ctx.fill();
            const orbitCount = 5 + Math.floor(energy * 10);
            for (let i = 0; i < orbitCount; i++) {
                const orbitRadius = 60 + i * 25 + Math.sin(time * 0.5 + i) * 15, orbitSpeed = (0.4 + energy * 0.8) + i * 0.1, angle = time * orbitSpeed + (i / orbitCount) * Math.PI * 2;
                const x = centerX + Math.cos(angle) * orbitRadius, y = centerY + Math.sin(angle) * orbitRadius, size = 8 + Math.sin(time + i) * 4 + energy * 12, hue = (hueBase + i * 30 + time * 10) % 360;
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, size);
                gradient.addColorStop(0, `hsla(${hue}, 100%, 80%, 1)`); gradient.addColorStop(0.5, `hsla(${hue}, 100%, 60%, 0.5)`); gradient.addColorStop(1, 'transparent');
                ctx.beginPath(); ctx.fillStyle = gradient; ctx.arc(x, y, size, 0, Math.PI * 2); ctx.fill();
            }
        }

        // MODE 6: 3D PIPES
        let pipes = [], pipeTimer = 0;
        function initPipes() { pipes = []; pipeTimer = 0; addNewPipe(); }
        function addNewPipe() { pipes.push({ points: [{ x: Math.random() * width * 0.6 + width * 0.2, y: Math.random() * height * 0.4 + height * 0.1, z: 0 }], direction: Math.floor(Math.random() * 6), hue: (hueBase + pipes.length * 60) % 360, thickness: 12 + energy * 12 }); }
        function drawPipes() {
            ctx.fillStyle = 'rgba(0, 0, 20, 0.05)'; ctx.fillRect(0, 0, width, height);
            pipeTimer += 0.3 + energy * 2.5;
            if (pipeTimer > 5) {
                pipeTimer = 0;
                pipes.forEach(pipe => {
                    const last = pipe.points[pipe.points.length - 1], step = 15 + energy * 20;
                    let newPoint = { ...last };
                    if (Math.random() < 0.15) pipe.direction = Math.floor(Math.random() * 4);
                    switch (pipe.direction) { case 0: newPoint.x += step; break; case 1: newPoint.x -= step; break; case 2: newPoint.y += step; break; case 3: newPoint.y -= step; break; }
                    if (newPoint.x < 50 || newPoint.x > width - 50) pipe.direction = pipe.direction === 0 ? 1 : 0;
                    if (newPoint.y < 50 || newPoint.y > height * 0.6) pipe.direction = pipe.direction === 2 ? 3 : 2;
                    newPoint.x = Math.max(50, Math.min(width - 50, newPoint.x)); newPoint.y = Math.max(50, Math.min(height * 0.6, newPoint.y));
                    pipe.points.push(newPoint); if (pipe.points.length > 100) pipe.points.shift();
                });
            }
            if (energy > 0.5 && pipes.length < 5 && Math.random() < 0.02) addNewPipe();
            pipes.forEach(pipe => {
                if (pipe.points.length < 2) return;
                for (let i = 1; i < pipe.points.length; i++) {
                    const p1 = pipe.points[i - 1], p2 = pipe.points[i], hue = (pipe.hue + i * 2 + time * 10) % 360;
                    const gradient = ctx.createLinearGradient(p1.x, p1.y - pipe.thickness, p1.x, p1.y + pipe.thickness);
                    gradient.addColorStop(0, `hsl(${hue}, 70%, 70%)`); gradient.addColorStop(0.3, `hsl(${hue}, 80%, 50%)`); gradient.addColorStop(0.7, `hsl(${hue}, 80%, 30%)`); gradient.addColorStop(1, `hsl(${hue}, 70%, 20%)`);
                    ctx.beginPath(); ctx.strokeStyle = gradient; ctx.lineWidth = pipe.thickness; ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
                    if (i < pipe.points.length - 1) {
                        const jointGrad = ctx.createRadialGradient(p2.x - 3, p2.y - 3, 0, p2.x, p2.y, pipe.thickness * 0.7);
                        jointGrad.addColorStop(0, `hsl(${hue}, 70%, 80%)`); jointGrad.addColorStop(0.5, `hsl(${hue}, 80%, 50%)`); jointGrad.addColorStop(1, `hsl(${hue}, 80%, 30%)`);
                        ctx.beginPath(); ctx.fillStyle = jointGrad; ctx.arc(p2.x, p2.y, pipe.thickness * 0.6, 0, Math.PI * 2); ctx.fill();
                    }
                }
            });
        }

        // MODE 7: MATRIX
        let matrixDrops = [];
        function initMatrix() { matrixDrops = []; const columns = Math.floor(width / 20); for (let i = 0; i < columns; i++) matrixDrops.push({ x: i * 20, y: Math.random() * -height, speed: Math.random() * 1 + 0.5, chars: [], length: Math.floor(Math.random() * 20) + 10 }); }
        function drawMatrix() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)'; ctx.fillRect(0, 0, width, height);
            const speedMult = 0.4 + energy * 2.5, chars = 'アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲン0123456789';
            matrixDrops.forEach(drop => {
                drop.y += drop.speed * speedMult;
                if (drop.y > height + drop.length * 20) { drop.y = Math.random() * -200; drop.speed = Math.random() * 1 + 0.5; drop.length = Math.floor(Math.random() * 20) + 10; }
                if (Math.random() < 0.1) { drop.chars = []; for (let i = 0; i < drop.length; i++) drop.chars.push(chars[Math.floor(Math.random() * chars.length)]); }
                for (let i = 0; i < drop.length; i++) {
                    const y = drop.y - i * 20; if (y < 0 || y > height) continue;
                    const char = drop.chars[i] || chars[Math.floor(Math.random() * chars.length)], brightness = 1 - (i / drop.length), hue = (hueBase + 120) % 360;
                    if (i === 0) { ctx.fillStyle = `hsla(${hue}, 100%, 90%, 1)`; ctx.font = 'bold 18px monospace'; }
                    else { ctx.fillStyle = `hsla(${hue}, 100%, ${50 * brightness + 20}%, ${brightness})`; ctx.font = '16px monospace'; }
                    ctx.fillText(char, drop.x, y);
                }
            });
            const glow = ctx.createRadialGradient(width / 2, height / 2, 0, width / 2, height / 2, width / 2);
            glow.addColorStop(0, `hsla(${(hueBase + 120) % 360}, 100%, 50%, ${0.03 + energy * 0.07})`); glow.addColorStop(1, 'transparent');
            ctx.fillStyle = glow; ctx.fillRect(0, 0, width, height);
        }

        // MODE 8: DVD BOUNCING LOGO
        let dvdLogos = [];
        function initDVD() { dvdLogos = [{ x: width / 2, y: height / 3, vx: 1.5, vy: 1, hue: hueBase, size: 100 }]; }
        function drawDVD() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.15)'; ctx.fillRect(0, 0, width, height);
            const speedMult = 0.5 + energy * 2;
            dvdLogos.forEach(logo => {
                logo.x += logo.vx * speedMult; logo.y += logo.vy * speedMult;
                if (logo.x <= logo.size || logo.x >= width - logo.size) { logo.vx *= -1; logo.hue = (logo.hue + 60) % 360; for (let i = 0; i < 10; i++) particles.push(new Particle(logo.x, logo.y, logo.hue, { size: Math.random() * 15 + 5, speedX: (Math.random() - 0.5) * 10, speedY: (Math.random() - 0.5) * 10, gravity: 0 })); }
                if (logo.y <= logo.size || logo.y >= height * 0.6 - logo.size) { logo.vy *= -1; logo.hue = (logo.hue + 60) % 360; for (let i = 0; i < 10; i++) particles.push(new Particle(logo.x, logo.y, logo.hue, { size: Math.random() * 15 + 5, speedX: (Math.random() - 0.5) * 10, speedY: (Math.random() - 0.5) * 10, gravity: 0 })); }
                logo.x = Math.max(logo.size, Math.min(width - logo.size, logo.x)); logo.y = Math.max(logo.size, Math.min(height * 0.6 - logo.size, logo.y));
                const hue = (logo.hue + time * 5) % 360;
                const glow = ctx.createRadialGradient(logo.x, logo.y, 0, logo.x, logo.y, logo.size * 1.5);
                glow.addColorStop(0, `hsla(${hue}, 100%, 60%, 0.3)`); glow.addColorStop(1, 'transparent');
                ctx.fillStyle = glow; ctx.fillRect(0, 0, width, height);
                ctx.save(); ctx.translate(logo.x, logo.y); ctx.font = `bold ${logo.size * 0.6}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillStyle = `hsla(${hue}, 100%, 20%, 0.8)`; ctx.fillText('DVD', 4, 4);
                const textGrad = ctx.createLinearGradient(-logo.size / 2, -logo.size / 2, logo.size / 2, logo.size / 2);
                textGrad.addColorStop(0, `hsl(${hue}, 100%, 70%)`); textGrad.addColorStop(0.5, `hsl(${(hue + 30) % 360}, 100%, 60%)`); textGrad.addColorStop(1, `hsl(${(hue + 60) % 360}, 100%, 70%)`);
                ctx.fillStyle = textGrad; ctx.fillText('DVD', 0, 0); ctx.restore();
            });
            if (energy > 0.7 && dvdLogos.length < 4 && Math.random() < 0.01) dvdLogos.push({ x: Math.random() * width * 0.6 + width * 0.2, y: Math.random() * height * 0.3 + height * 0.1, vx: (Math.random() - 0.5) * 3, vy: (Math.random() - 0.5) * 3, hue: (hueBase + dvdLogos.length * 90) % 360, size: 80 });
        }

        // MODE 9: FIREWORKS
        let fireworks = [], fireworkParticles = [];
        function drawFireworks() {
            ctx.fillStyle = 'rgba(0, 0, 10, 0.2)'; ctx.fillRect(0, 0, width, height);
            const maxFireworkParticles = 500;
            if (fireworkParticles.length < maxFireworkParticles && Math.random() < 0.005 + energy * 0.05) fireworks.push({ x: Math.random() * width * 0.8 + width * 0.1, y: height, vy: -5 - Math.random() * 3 - energy * 4, targetY: Math.random() * height * 0.3 + height * 0.1, hue: (hueBase + Math.random() * 60) % 360 });
            fireworks = fireworks.filter(fw => {
                fw.y += fw.vy; fw.vy += 0.1;
                ctx.beginPath(); ctx.fillStyle = `hsla(${fw.hue}, 100%, 80%, 0.8)`; ctx.arc(fw.x, fw.y, 3, 0, Math.PI * 2); ctx.fill();
                if (fw.y <= fw.targetY || fw.vy >= 0) {
                    const particleCount = Math.min(40 + energy * 20, 60), availableSlots = maxFireworkParticles - fireworkParticles.length, actualCount = Math.min(particleCount, availableSlots);
                    for (let i = 0; i < actualCount; i++) { const angle = (i / actualCount) * Math.PI * 2, speed = Math.random() * 5 + 2; fireworkParticles.push({ x: fw.x, y: fw.y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, hue: (fw.hue + Math.random() * 40 - 20) % 360, life: 1, decay: 0.02 + Math.random() * 0.015 }); }
                    return false;
                }
                return true;
            });
            fireworkParticles = fireworkParticles.filter(p => {
                p.x += p.vx; p.y += p.vy; p.vy += 0.08; p.vx *= 0.98; p.life -= p.decay;
                if (p.life <= 0) return false;
                const size = Math.max(0.5, p.life * 4);
                ctx.beginPath(); ctx.fillStyle = `hsla(${p.hue}, 100%, ${50 + p.life * 30}%, ${p.life})`; ctx.arc(p.x, p.y, size, 0, Math.PI * 2); ctx.fill();
                return true;
            });
        }

        // MODE 10: MYSTIFY (WORMS)
        let worms = [];
        function initWorms() { worms = []; for (let i = 0; i < 3; i++) { worms.push({ points: [], vx: (Math.random() - 0.5) * 2, vy: (Math.random() - 0.5) * 2, hue: (hueBase + i * 120) % 360, maxLength: 50 }); worms[i].points.push({ x: Math.random() * width * 0.6 + width * 0.2, y: Math.random() * height * 0.3 + height * 0.1 }); } }
        function drawWorms() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.08)'; ctx.fillRect(0, 0, width, height);
            const speedMult = 0.4 + energy * 1.8;
            worms.forEach(worm => {
                if (worm.points.length === 0) return;
                const head = worm.points[worm.points.length - 1];
                let newX = head.x + worm.vx * speedMult, newY = head.y + worm.vy * speedMult;
                if (newX < 0 || newX > width) { worm.vx *= -1; newX = Math.max(0, Math.min(width, newX)); worm.hue = (worm.hue + 30) % 360; }
                if (newY < 0 || newY > height * 0.6) { worm.vy *= -1; newY = Math.max(0, Math.min(height * 0.6, newY)); worm.hue = (worm.hue + 30) % 360; }
                if (Math.random() < 0.02) { worm.vx += (Math.random() - 0.5) * 1.5; worm.vy += (Math.random() - 0.5) * 1.5; const speed = Math.sqrt(worm.vx * worm.vx + worm.vy * worm.vy), maxSpeed = 3 + energy * 4; if (speed > maxSpeed) { worm.vx = (worm.vx / speed) * maxSpeed; worm.vy = (worm.vy / speed) * maxSpeed; } }
                worm.points.push({ x: newX, y: newY }); const maxLen = worm.maxLength + energy * 30; if (worm.points.length > maxLen) worm.points.shift();
                if (worm.points.length > 1) {
                    ctx.beginPath(); ctx.moveTo(worm.points[0].x, worm.points[0].y);
                    for (let i = 1; i < worm.points.length; i++) ctx.lineTo(worm.points[i].x, worm.points[i].y);
                    const hue = (worm.hue + time * 10) % 360;
                    ctx.strokeStyle = `hsla(${hue}, 100%, 60%, 0.8)`; ctx.lineWidth = 2 + energy * 2; ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.stroke();
                    ctx.strokeStyle = `hsla(${hue}, 100%, 70%, 0.3)`; ctx.lineWidth = 6 + energy * 4; ctx.stroke();
                }
            });
            if (energy > 0.6 && worms.length < 6 && Math.random() < 0.01) worms.push({ points: [{ x: Math.random() * width * 0.6 + width * 0.2, y: Math.random() * height * 0.3 + height * 0.1 }], vx: (Math.random() - 0.5) * 2, vy: (Math.random() - 0.5) * 2, hue: (hueBase + worms.length * 60) % 360, maxLength: 50 });
        }


        // MODE 11: UNDERWATER OCEAN
        let fish = [];
        let oceanBubbles = [];
        function initOcean() {
            fish = [];
            oceanBubbles = [];
            for (let i = 0; i < 15; i++) {
                fish.push({
                    x: Math.random() * width,
                    y: Math.random() * height * 0.8,
                    vx: (Math.random() - 0.5) * 2,
                    vy: 0,
                    size: Math.random() * 20 + 15,
                    hue: [30, 45, 180, 200, 350][Math.floor(Math.random() * 5)],
                    scared: false,
                    scareTime: 0
                });
            }
            for (let i = 0; i < 20; i++) {
                oceanBubbles.push({
                    x: Math.random() * width,
                    y: height + Math.random() * 100,
                    size: Math.random() * 8 + 3,
                    speed: Math.random() * 0.5 + 0.3
                });
            }
        }

        function drawOcean() {
            // Ocean background
            const bgGrad = ctx.createLinearGradient(0, 0, 0, height);
            bgGrad.addColorStop(0, `hsl(200, 70%, 10%)`);
            bgGrad.addColorStop(0.5, `hsl(200, 60%, 15%)`);
            bgGrad.addColorStop(1, `hsl(180, 50%, 8%)`);
            ctx.fillStyle = bgGrad;
            ctx.fillRect(0, 0, width, height);

            // Light rays
            for (let i = 0; i < 5; i++) {
                const x = width * (0.2 + i * 0.15) + Math.sin(time * 0.3 + i) * 50;
                const grad = ctx.createLinearGradient(x, 0, x + 100, height);
                grad.addColorStop(0, 'rgba(100, 200, 255, 0.08)');
                grad.addColorStop(0.5, 'rgba(100, 200, 255, 0.03)');
                grad.addColorStop(1, 'transparent');
                ctx.fillStyle = grad;
                ctx.fillRect(x, 0, 100, height);
            }

            // Fish swim and scatter
            fish.forEach(f => {
                if (f.scared && time - f.scareTime < 1) {
                    f.vx += (Math.random() - 0.5) * 0.5;
                    f.vy += (Math.random() - 0.5) * 0.5;
                } else {
                    f.scared = false;
                    f.vx += (Math.random() - 0.5) * 0.1;
                    f.vy += (Math.random() - 0.5) * 0.05;
                }

                const speed = Math.sqrt(f.vx * f.vx + f.vy * f.vy);
                const maxSpeed = f.scared ? 6 : 2;
                if (speed > maxSpeed) {
                    f.vx = (f.vx / speed) * maxSpeed;
                    f.vy = (f.vy / speed) * maxSpeed;
                }

                f.x += f.vx * (0.5 + energy);
                f.y += f.vy;

                if (f.x < 0) f.x = width;
                if (f.x > width) f.x = 0;
                if (f.y < 0) f.y = height * 0.8;
                if (f.y > height * 0.8) f.y = 0;

                // Draw fish
                ctx.save();
                ctx.translate(f.x, f.y);
                if (f.vx < 0) ctx.scale(-1, 1);

                // Fish body
                ctx.beginPath();
                ctx.ellipse(0, 0, f.size, f.size * 0.6, 0, 0, Math.PI * 2);
                const fishGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, f.size);
                fishGrad.addColorStop(0, `hsla(${f.hue}, 80%, 60%, 0.9)`);
                fishGrad.addColorStop(1, `hsla(${f.hue}, 70%, 40%, 0.7)`);
                ctx.fillStyle = fishGrad;
                ctx.fill();

                // Fish tail
                ctx.beginPath();
                ctx.moveTo(-f.size, 0);
                ctx.lineTo(-f.size * 1.4, -f.size * 0.5);
                ctx.lineTo(-f.size * 1.4, f.size * 0.5);
                ctx.closePath();
                ctx.fillStyle = `hsla(${f.hue}, 70%, 50%, 0.8)`;
                ctx.fill();

                ctx.restore();
            });

            // Bubbles
            oceanBubbles.forEach(b => {
                b.y -= b.speed * (1 + energy);
                if (b.y < -b.size) {
                    b.y = height + b.size;
                    b.x = Math.random() * width;
                }

                const bubbleGrad = ctx.createRadialGradient(b.x - b.size * 0.3, b.y - b.size * 0.3, 0, b.x, b.y, b.size);
                bubbleGrad.addColorStop(0, 'rgba(200, 240, 255, 0.5)');
                bubbleGrad.addColorStop(0.5, 'rgba(150, 220, 255, 0.2)');
                bubbleGrad.addColorStop(1, 'rgba(100, 200, 255, 0.05)');
                ctx.beginPath();
                ctx.arc(b.x, b.y, b.size, 0, Math.PI * 2);
                ctx.fillStyle = bubbleGrad;
                ctx.fill();
            });

            // Scare fish when typing
            if (energy > 0.3 && Math.random() < energy * 0.1) {
                fish.forEach(f => {
                    if (Math.random() < 0.3) {
                        f.scared = true;
                        f.scareTime = time;
                    }
                });
            }

            // Add more bubbles with energy
            if (energy > 0.5 && oceanBubbles.length < 40 && Math.random() < 0.1) {
                oceanBubbles.push({
                    x: Math.random() * width,
                    y: height,
                    size: Math.random() * 8 + 3,
                    speed: Math.random() * 0.5 + 0.3
                });
            }
        }

        // MODE 12: GARDEN
        let flowers = [];
        let butterflies = [];
        function initGarden() {
            flowers = [];
            butterflies = [];
            for (let i = 0; i < 8; i++) {
                flowers.push({
                    x: Math.random() * width,
                    growth: Math.random() * 0.5 + 0.3,
                    hue: Math.random() * 360,
                    petalCount: Math.floor(Math.random() * 3) + 5
                });
            }
            for (let i = 0; i < 6; i++) {
                butterflies.push({
                    x: Math.random() * width,
                    y: Math.random() * height * 0.6,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 1,
                    hue: Math.random() * 360,
                    wingPhase: Math.random() * Math.PI * 2
                });
            }
        }

        function drawGarden() {
            // Sky to grass gradient
            const bgGrad = ctx.createLinearGradient(0, 0, 0, height);
            bgGrad.addColorStop(0, `hsl(200, 60%, 70%)`);
            bgGrad.addColorStop(0.7, `hsl(180, 50%, 60%)`);
            bgGrad.addColorStop(1, `hsl(100, 50%, 35%)`);
            ctx.fillStyle = bgGrad;
            ctx.fillRect(0, 0, width, height);

            // Sun
            const sunGrad = ctx.createRadialGradient(width * 0.8, height * 0.15, 0, width * 0.8, height * 0.15, 60);
            sunGrad.addColorStop(0, 'rgba(255, 250, 150, 0.9)');
            sunGrad.addColorStop(0.5, 'rgba(255, 240, 100, 0.5)');
            sunGrad.addColorStop(1, 'transparent');
            ctx.fillStyle = sunGrad;
            ctx.beginPath();
            ctx.arc(width * 0.8, height * 0.15, 60, 0, Math.PI * 2);
            ctx.fill();

            // Grass
            ctx.fillStyle = `hsl(100, 50%, 30%)`;
            ctx.fillRect(0, height * 0.75, width, height * 0.25);

            // Flowers
            flowers.forEach(f => {
                const flowerHeight = height * 0.75 - f.growth * height * 0.4;

                // Stem
                ctx.beginPath();
                ctx.strokeStyle = `hsl(100, 60%, 35%)`;
                ctx.lineWidth = 3;
                ctx.moveTo(f.x, height * 0.75);
                ctx.quadraticCurveTo(f.x + Math.sin(time + f.x) * 10, height * 0.75 - f.growth * height * 0.2, f.x, flowerHeight);
                ctx.stroke();

                // Flower petals
                for (let i = 0; i < f.petalCount; i++) {
                    const angle = (i / f.petalCount) * Math.PI * 2;
                    const petalX = f.x + Math.cos(angle) * 15;
                    const petalY = flowerHeight + Math.sin(angle) * 15;

                    ctx.beginPath();
                    ctx.arc(petalX, petalY, 10, 0, Math.PI * 2);
                    ctx.fillStyle = `hsla(${f.hue}, 80%, 60%, 0.9)`;
                    ctx.fill();
                }

                // Flower center
                ctx.beginPath();
                ctx.arc(f.x, flowerHeight, 8, 0, Math.PI * 2);
                ctx.fillStyle = `hsl(${(f.hue + 180) % 360}, 70%, 50%)`;
                ctx.fill();

                // Grow flowers with typing
                if (f.growth < 1) f.growth += 0.001 + energy * 0.005;
            });

            // Butterflies
            butterflies.forEach(b => {
                b.x += b.vx * (0.5 + energy);
                b.y += b.vy + Math.sin(time * 2 + b.x) * 0.5;
                b.wingPhase += 0.1 + energy * 0.1;

                if (b.x < -20) b.x = width + 20;
                if (b.x > width + 20) b.x = -20;
                if (b.y < 0) b.y = height * 0.6;
                if (b.y > height * 0.6) b.y = 0;

                const wingFlap = Math.abs(Math.sin(b.wingPhase)) * 0.5 + 0.5;

                // Butterfly body
                ctx.beginPath();
                ctx.ellipse(b.x, b.y, 3, 8, Math.PI / 2, 0, Math.PI * 2);
                ctx.fillStyle = '#000';
                ctx.fill();

                // Wings
                ctx.save();
                ctx.translate(b.x, b.y);
                for (let side of [-1, 1]) {
                    ctx.beginPath();
                    ctx.ellipse(side * 8, -3, 10 * wingFlap, 8, side * 0.3, 0, Math.PI * 2);
                    ctx.fillStyle = `hsla(${b.hue}, 80%, 60%, 0.8)`;
                    ctx.fill();

                    ctx.beginPath();
                    ctx.ellipse(side * 7, 3, 8 * wingFlap, 6, side * -0.2, 0, Math.PI * 2);
                    ctx.fillStyle = `hsla(${b.hue + 20}, 75%, 55%, 0.7)`;
                    ctx.fill();
                }
                ctx.restore();
            });

            // Spawn new flowers with typing
            if (energy > 0.5 && flowers.length < 20 && Math.random() < 0.02) {
                flowers.push({
                    x: Math.random() * width,
                    growth: 0,
                    hue: Math.random() * 360,
                    petalCount: Math.floor(Math.random() * 3) + 5
                });
            }

            // Spawn butterflies
            if (energy > 0.6 && butterflies.length < 12 && Math.random() < 0.01) {
                butterflies.push({
                    x: Math.random() * width,
                    y: Math.random() * height * 0.6,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 1,
                    hue: Math.random() * 360,
                    wingPhase: 0
                });
            }
        }

        // MODE 13: ROCKETS
        let rockets = [];
        function initRockets() {
            rockets = [];
        }

        function drawRockets() {
            // Space background
            ctx.fillStyle = '#000510';
            ctx.fillRect(0, 0, width, height);

            // Stars
            for (let i = 0; i < 50; i++) {
                const x = (i * 137.5) % width;
                const y = (i * 217.3) % height;
                const twinkle = Math.sin(time * 2 + i) * 0.3 + 0.7;
                ctx.fillStyle = `rgba(255, 255, 255, ${twinkle * 0.7})`;
                ctx.fillRect(x, y, 2, 2);
            }

            // Launch rockets with typing
            if (energy > 0.2 && Math.random() < energy * 0.05) {
                rockets.push({
                    x: Math.random() * width,
                    y: height,
                    vx: (Math.random() - 0.5) * 2,
                    vy: -3 - energy * 5,
                    hue: Math.random() * 360,
                    trail: [],
                    exploded: false,
                    life: 1
                });
            }

            // Update and draw rockets
            rockets = rockets.filter(r => r.life > 0);
            rockets.forEach(r => {
                if (!r.exploded) {
                    r.x += r.vx;
                    r.y += r.vy;
                    r.vy += 0.05; // Gravity

                    // Add trail point
                    r.trail.push({ x: r.x, y: r.y, life: 1 });
                    if (r.trail.length > 20) r.trail.shift();

                    // Explode if slowing down or hitting top
                    if (r.vy > -1 || r.y < height * 0.2) {
                        r.exploded = true;
                        // Create explosion particles
                        for (let i = 0; i < 30; i++) {
                            const angle = (i / 30) * Math.PI * 2;
                            const speed = Math.random() * 3 + 2;
                            particles.push(new Particle(
                                r.x, r.y, r.hue + Math.random() * 60 - 30,
                                {
                                    size: Math.random() * 20 + 10,
                                    speedX: Math.cos(angle) * speed,
                                    speedY: Math.sin(angle) * speed,
                                    decay: 0.015,
                                    gravity: 0.08
                                }
                            ));
                        }
                    } else {
                        // Draw rocket
                        ctx.save();
                        ctx.translate(r.x, r.y);
                        const angle = Math.atan2(r.vy, r.vx) + Math.PI / 2;
                        ctx.rotate(angle);

                        // Rocket body
                        ctx.beginPath();
                        ctx.moveTo(0, -15);
                        ctx.lineTo(-5, 15);
                        ctx.lineTo(5, 15);
                        ctx.closePath();
                        ctx.fillStyle = `hsl(${r.hue}, 80%, 60%)`;
                        ctx.fill();

                        // Nose cone
                        ctx.beginPath();
                        ctx.moveTo(0, -20);
                        ctx.lineTo(-5, -15);
                        ctx.lineTo(5, -15);
                        ctx.closePath();
                        ctx.fillStyle = `hsl(${r.hue + 20}, 70%, 50%)`;
                        ctx.fill();

                        ctx.restore();

                        // Exhaust
                        const exhaustGrad = ctx.createRadialGradient(r.x, r.y + 15, 0, r.x, r.y + 15, 20);
                        exhaustGrad.addColorStop(0, `hsla(30, 100%, 70%, 0.9)`);
                        exhaustGrad.addColorStop(0.5, `hsla(15, 100%, 50%, 0.5)`);
                        exhaustGrad.addColorStop(1, 'transparent');
                        ctx.fillStyle = exhaustGrad;
                        ctx.beginPath();
                        ctx.arc(r.x, r.y + 15, 20, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else {
                    r.life -= 0.02;
                }

                // Draw trail
                r.trail.forEach((t, i) => {
                    t.life -= 0.05;
                    const alpha = t.life * (i / r.trail.length);
                    ctx.fillStyle = `hsla(${r.hue}, 80%, 60%, ${alpha * 0.6})`;
                    ctx.beginPath();
                    ctx.arc(t.x, t.y, 3, 0, Math.PI * 2);
                    ctx.fill();
                });
                r.trail = r.trail.filter(t => t.life > 0);
            });
        }

        // MODE 14: MUSICAL NOTES
        let musicalNotes = [];
        function initMusic() {
            musicalNotes = [];
        }

        function drawMusic() {
            // Soft gradient background
            const bgGrad = ctx.createLinearGradient(0, 0, 0, height);
            bgGrad.addColorStop(0, `hsl(${(hueBase + 180) % 360}, 40%, 20%)`);
            bgGrad.addColorStop(1, `hsl(${hueBase}, 50%, 10%)`);
            ctx.fillStyle = bgGrad;
            ctx.fillRect(0, 0, width, height);

            // Spawn notes when typing
            if (energy > 0.2 && Math.random() < energy * 0.15) {
                const symbols = ['♪', '♫', '♬', '♩', '♭', '♮', '♯'];
                musicalNotes.push({
                    x: Math.random() * width,
                    y: 0,
                    vx: (Math.random() - 0.5) * 3,
                    vy: Math.random() * 2 + 1,
                    symbol: symbols[Math.floor(Math.random() * symbols.length)],
                    hue: (hueBase + Math.random() * 60) % 360,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.1,
                    size: Math.random() * 30 + 30,
                    bounces: 0
                });
            }

            // Update and draw notes
            musicalNotes = musicalNotes.filter(n => n.bounces < 3 && n.y < height + 50);
            musicalNotes.forEach(n => {
                n.vy += 0.2; // Gravity
                n.x += n.vx;
                n.y += n.vy;
                n.rotation += n.rotationSpeed;

                // Bounce off bottom
                if (n.y > height - n.size / 2) {
                    n.y = height - n.size / 2;
                    n.vy *= -0.7;
                    n.vx *= 0.9;
                    n.bounces++;

                    // Create "sound wave" effect on bounce
                    for (let i = 0; i < 3; i++) {
                        setTimeout(() => {
                            const waveRadius = i * 40;
                            ctx.beginPath();
                            ctx.arc(n.x, height - n.size / 2, waveRadius, 0, Math.PI * 2);
                            ctx.strokeStyle = `hsla(${n.hue}, 70%, 60%, ${0.3 - i * 0.1})`;
                            ctx.lineWidth = 2;
                            ctx.stroke();
                        }, i * 100);
                    }
                }

                // Bounce off sides
                if (n.x < n.size / 2 || n.x > width - n.size / 2) {
                    n.vx *= -0.8;
                    n.x = Math.max(n.size / 2, Math.min(width - n.size / 2, n.x));
                }

                // Draw note
                ctx.save();
                ctx.translate(n.x, n.y);
                ctx.rotate(n.rotation);
                ctx.font = `${n.size}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = `hsla(${n.hue}, 80%, 60%, 0.9)`;
                ctx.fillText(n.symbol, 0, 0);
                ctx.strokeStyle = `hsla(${n.hue}, 90%, 70%, 0.5)`;
                ctx.lineWidth = 2;
                ctx.strokeText(n.symbol, 0, 0);
                ctx.restore();
            });

            // Animated staff lines
            for (let i = 0; i < 5; i++) {
                const y = height * 0.4 + i * 20 + Math.sin(time + i) * 3;
                ctx.strokeStyle = `hsla(${hueBase}, 30%, 50%, 0.2)`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
        }

        // MODE 15: WEATHER
        let weatherParticles = [];
        let weatherType = 'rain'; // rain, snow, or lightning
        let weatherTimer = 0;
        function initWeather() {
            weatherParticles = [];
            weatherType = 'rain';
            weatherTimer = 0;
        }

        function drawWeather() {
            weatherTimer += 0.016;

            // Change weather type based on energy
            if (weatherTimer > 8) {
                weatherTimer = 0;
                const types = ['rain', 'snow', 'lightning'];
                weatherType = types[Math.floor(Math.random() * types.length)];
                weatherParticles = [];
            }

            // Background based on weather
            let bgGrad = ctx.createLinearGradient(0, 0, 0, height);
            if (weatherType === 'rain') {
                bgGrad.addColorStop(0, 'hsl(220, 30%, 20%)');
                bgGrad.addColorStop(1, 'hsl(210, 25%, 35%)');
            } else if (weatherType === 'snow') {
                bgGrad.addColorStop(0, 'hsl(200, 20%, 60%)');
                bgGrad.addColorStop(1, 'hsl(210, 15%, 80%)');
            } else {
                bgGrad.addColorStop(0, 'hsl(270, 20%, 10%)');
                bgGrad.addColorStop(1, 'hsl(260, 25%, 20%)');
            }
            ctx.fillStyle = bgGrad;
            ctx.fillRect(0, 0, width, height);

            // Spawn particles
            const spawnRate = 3 + energy * 10;
            for (let i = 0; i < spawnRate; i++) {
                if (weatherType === 'rain') {
                    weatherParticles.push({
                        x: Math.random() * width,
                        y: -10,
                        vy: Math.random() * 5 + 10,
                        length: Math.random() * 20 + 10
                    });
                } else if (weatherType === 'snow') {
                    weatherParticles.push({
                        x: Math.random() * width,
                        y: -10,
                        vx: (Math.random() - 0.5) * 1,
                        vy: Math.random() * 1 + 1,
                        size: Math.random() * 4 + 2,
                        wobble: Math.random() * Math.PI * 2
                    });
                }
            }

            // Lightning
            if (weatherType === 'lightning' && Math.random() < 0.02 + energy * 0.03) {
                // Flash
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.fillRect(0, 0, width, height);

                // Lightning bolt
                const startX = Math.random() * width;
                let x = startX;
                let y = 0;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.strokeStyle = 'rgba(200, 220, 255, 0.9)';
                ctx.lineWidth = 3;
                ctx.shadowBlur = 10;
                ctx.shadowColor = 'rgba(150, 200, 255, 0.8)';

                while (y < height) {
                    x += (Math.random() - 0.5) * 50;
                    y += Math.random() * 50 + 30;
                    ctx.lineTo(x, y);
                }
                ctx.stroke();
                ctx.shadowBlur = 0;
            }

            // Update and draw weather particles
            weatherParticles = weatherParticles.filter(p => p.y < height + 20);

            if (weatherType === 'rain') {
                weatherParticles.forEach(p => {
                    p.y += p.vy * (1 + energy * 0.5);

                    ctx.beginPath();
                    ctx.strokeStyle = 'rgba(150, 180, 220, 0.5)';
                    ctx.lineWidth = 1.5;
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(p.x, p.y + p.length);
                    ctx.stroke();

                    // Splash at bottom
                    if (p.y > height - 5) {
                        ctx.beginPath();
                        ctx.arc(p.x, height, 5, 0, Math.PI, true);
                        ctx.strokeStyle = 'rgba(150, 180, 220, 0.3)';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                });
            } else if (weatherType === 'snow') {
                weatherParticles.forEach(p => {
                    p.wobble += 0.02;
                    p.x += Math.sin(p.wobble) * 0.5 + p.vx;
                    p.y += p.vy * (0.5 + energy * 0.5);

                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.fill();

                    // Sparkle
                    ctx.beginPath();
                    ctx.arc(p.x - p.size * 0.3, p.y - p.size * 0.3, p.size * 0.4, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.fill();
                });
            }

            // Ground accumulation for snow
            if (weatherType === 'snow') {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.fillRect(0, height - 20, width, 20);
            }
        }

        // MODE 16: KALEIDOSCOPE
        function drawKaleidoscope() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, width, height);

            const centerX = width / 2;
            const centerY = height / 2;
            const segments = 6 + Math.floor(energy * 6);
            const rotation = time * (0.5 + energy);
            const maxRadius = Math.min(width, height) * 0.4;

            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(rotation);

            for (let seg = 0; seg < segments; seg++) {
                const angle = (seg / segments) * Math.PI * 2;

                ctx.save();
                ctx.rotate(angle);

                // Draw multiple layers
                for (let layer = 0; layer < 5; layer++) {
                    const radius = (layer / 5) * maxRadius * (0.7 + energy * 0.3);
                    const pulseSize = Math.sin(time * 2 + layer) * 10 + 20;
                    const hue = (hueBase + layer * 60 + seg * 20) % 360;

                    // Geometric shapes
                    ctx.beginPath();
                    const sides = 3 + layer;
                    for (let i = 0; i <= sides; i++) {
                        const shapeAngle = (i / sides) * Math.PI * 2;
                        const x = Math.cos(shapeAngle) * (pulseSize + radius);
                        const y = Math.sin(shapeAngle) * (pulseSize + radius);
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }

                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, pulseSize + radius);
                    gradient.addColorStop(0, `hsla(${hue}, 100%, 60%, ${0.6 - layer * 0.1})`);
                    gradient.addColorStop(0.5, `hsla(${hue + 30}, 80%, 50%, ${0.4 - layer * 0.08})`);
                    gradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = gradient;
                    ctx.fill();

                    ctx.strokeStyle = `hsla(${hue}, 90%, 70%, ${0.5 - layer * 0.1})`;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }

                ctx.restore();
            }

            ctx.restore();

            // Center glow
            const centerGlow = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 50 + energy * 50);
            centerGlow.addColorStop(0, `hsla(${hueBase}, 100%, 80%, 0.8)`);
            centerGlow.addColorStop(1, 'transparent');
            ctx.fillStyle = centerGlow;
            ctx.beginPath();
            ctx.arc(centerX, centerY, 50 + energy * 50, 0, Math.PI * 2);
            ctx.fill();
        }

        // MODE 17: PARTICLE SWARM
        let swarmParticles = [];
        let swarmTarget = { x: 0, y: 0 };
        let swarmShape = 'circle';
        function initSwarm() {
            swarmParticles = [];
            for (let i = 0; i < 150; i++) {
                swarmParticles.push({
                    x: Math.random() * width,
                    y: Math.random() * height,
                    vx: 0,
                    vy: 0,
                    hue: Math.random() * 360
                });
            }
            swarmTarget = { x: width / 2, y: height / 2 };
            swarmShape = 'circle';
        }

        function drawSwarm() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
            ctx.fillRect(0, 0, width, height);

            // Change shape periodically
            if (Math.floor(time) % 5 === 0 && time % 1 < 0.02) {
                const shapes = ['circle', 'spiral', 'heart', 'wave'];
                swarmShape = shapes[Math.floor(Math.random() * shapes.length)];
            }

            // Move target smoothly
            swarmTarget.x += (Math.random() - 0.5) * 5;
            swarmTarget.y += (Math.random() - 0.5) * 5;
            swarmTarget.x = Math.max(100, Math.min(width - 100, swarmTarget.x));
            swarmTarget.y = Math.max(100, Math.min(height - 100, swarmTarget.y));

            // Update swarm particles
            swarmParticles.forEach((p, i) => {
                // Calculate target position based on shape
                let targetX, targetY;
                const angle = (i / swarmParticles.length) * Math.PI * 2;
                const radius = 100 + energy * 100;

                if (swarmShape === 'circle') {
                    targetX = swarmTarget.x + Math.cos(angle) * radius;
                    targetY = swarmTarget.y + Math.sin(angle) * radius;
                } else if (swarmShape === 'spiral') {
                    const spiralRadius = (i / swarmParticles.length) * radius;
                    targetX = swarmTarget.x + Math.cos(angle + time) * spiralRadius;
                    targetY = swarmTarget.y + Math.sin(angle + time) * spiralRadius;
                } else if (swarmShape === 'heart') {
                    const t = angle;
                    targetX = swarmTarget.x + radius * 0.5 * (16 * Math.pow(Math.sin(t), 3));
                    targetY = swarmTarget.y - radius * 0.5 * (13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));
                } else { // wave
                    targetX = swarmTarget.x - radius + (i / swarmParticles.length) * radius * 2;
                    targetY = swarmTarget.y + Math.sin(angle * 3 + time * 2) * radius * 0.5;
                }

                // Flocking behavior
                const dx = targetX - p.x;
                const dy = targetY - p.y;
                p.vx += dx * 0.001;
                p.vy += dy * 0.001;

                // Add some randomness and neighbor awareness
                p.vx += (Math.random() - 0.5) * 0.2;
                p.vy += (Math.random() - 0.5) * 0.2;

                // Damping
                p.vx *= 0.95;
                p.vy *= 0.95;

                p.x += p.vx * (1 + energy);
                p.y += p.vy * (1 + energy);

                // Draw particle
                ctx.beginPath();
                ctx.arc(p.x, p.y, 3 + energy * 2, 0, Math.PI * 2);
                const particleHue = (p.hue + time * 50) % 360;
                ctx.fillStyle = `hsla(${particleHue}, 80%, 60%, 0.8)`;
                ctx.fill();

                // Draw connections to nearby particles
                swarmParticles.forEach((other, j) => {
                    if (j <= i) return;
                    const dist = Math.hypot(p.x - other.x, p.y - other.y);
                    if (dist < 50) {
                        ctx.beginPath();
                        ctx.moveTo(p.x, p.y);
                        ctx.lineTo(other.x, other.y);
                        ctx.strokeStyle = `hsla(${particleHue}, 70%, 50%, ${1 - dist / 50})`;
                        ctx.lineWidth = 0.5;
                        ctx.stroke();
                    }
                });
            });

            // Add more particles with energy
            if (energy > 0.5 && swarmParticles.length < 250 && Math.random() < 0.05) {
                swarmParticles.push({
                    x: Math.random() * width,
                    y: Math.random() * height,
                    vx: 0,
                    vy: 0,
                    hue: Math.random() * 360
                });
            }
        }


        // MAIN FUNCTIONS
        function resize() {
            width = canvas.width = window.innerWidth; height = canvas.height = window.innerHeight;
            traceCanvas.width = width; traceCanvas.height = height;
            prepareTraceAnalysis();
            initStars(); initBubbles(); initPipes(); initMatrix(); initDVD(); initWorms();
            initOcean(); initGarden(); initRockets(); initMusic(); initWeather(); initSwarm();
            showNextTraceLetter(); // Recalculate letter position
        }

        function animate() {
            time += 0.016; energy += (targetEnergy - energy) * 0.1; targetEnergy *= 0.995;
            switch (currentMode) {
                case 1: drawOceanWaves(); break; case 2: drawStarfield(); break; case 3: drawBubbles(); break; case 4: drawFire(); break; case 5: drawRainbowSpiral(); break;
                case 6: drawPipes(); break; case 7: drawMatrix(); break; case 8: drawDVD(); break; case 9: drawFireworks(); break; case 10: drawWorms(); break;
                case 11: drawOcean(); break; case 12: drawGarden(); break; case 13: drawRockets(); break; case 14: drawMusic(); break; case 15: drawWeather(); break;
                case 16: drawKaleidoscope(); break; case 17: drawSwarm(); break;
            }
            particles = particles.filter(p => p.life > 0); particles.forEach(p => { p.update(); p.draw(); });
            requestAnimationFrame(animate);
        }

        // --- MOBILE/TOUCH TRACING HANDLERS ---

        function handleTraceStart(x, y) {
            if (!isMobile) return;
            isTracing = true; lastTraceX = x; lastTraceY = y; targetEnergy = Math.min(1, targetEnergy + 0.05);
        }
        function handleTraceMove(x, y) {
            if (!isTracing || !isMobile) return;
            targetEnergy = Math.min(1, targetEnergy + 0.02); hueBase = (hueBase + 2) % 360;
            traceCtx.beginPath(); traceCtx.strokeStyle = `hsla(${hueBase}, 100%, 60%, 0.8)`; traceCtx.lineWidth = 20; traceCtx.lineCap = 'round'; traceCtx.moveTo(lastTraceX, lastTraceY); traceCtx.lineTo(x, y); traceCtx.stroke();
            traceCtx.beginPath(); traceCtx.strokeStyle = `hsla(${hueBase}, 100%, 70%, 0.3)`; traceCtx.lineWidth = 35; traceCtx.moveTo(lastTraceX, lastTraceY); traceCtx.lineTo(x, y); traceCtx.stroke();
            if (Math.random() < 0.3) particles.push(new Particle(x, y, hueBase, { size: Math.random() * 15 + 5, speedX: (Math.random() - 0.5) * 4, speedY: (Math.random() - 0.5) * 4, gravity: 0.02 }));
            lastTraceX = x; lastTraceY = y;
        }
        function handleTraceEnd() {
            if (isTracing && isMobile) {
                isTracing = false;

                // Check coverage on lift
                const coverage = checkTraceProgress();
                if (coverage >= 0.8) {
                    // Use the displayed character for the typed text
                    updateText(currentTraceLetter);
                    flashLetter();
                    setTimeout(() => showNextTraceLetter(), 300);
                }
            }
        }

        function handleReset() {
            typedString = '';
            textDisplay.innerHTML = '';
            if (isMobile) traceCtx.clearRect(0, 0, traceCanvas.width, traceCanvas.height);
            targetEnergy += 0.5; // Little burst of energy on clear
            if (!isMobile && isChallengeMode) showNextTraceLetter();
        }


        // --- Event Listeners ---

        // This is only for the mobile virtual keyboard fallback
        document.addEventListener('keydown', (e) => {
            if (!isMobile) return;
            // Desktop handler is active for non-mobile devices
            if (e.key === ' ') e.preventDefault();
            if (e.key === 'Shift' || e.key === 'Control' || e.key === 'Alt' || e.key === 'Meta') return;
            updateText(e.key);
        });

        keyboardToggle.addEventListener('click', (e) => {
            e.preventDefault(); e.stopPropagation();
            if (keyboardVisible) { mobileInput.blur(); keyboardToggle.textContent = 'Keyboard'; keyboardVisible = false; }
            else { mobileInput.focus(); keyboardToggle.textContent = 'Hide'; keyboardVisible = true; }
        });

        resetBtn.addEventListener('click', handleReset);

        freeTextToggle.addEventListener('click', toggleChallengeMode);

        mobileInput.addEventListener('input', (e) => { const value = e.target.value; if (value.length > 0) updateText(value[value.length - 1]); if (mobileInput.value.length > 5) mobileInput.value = mobileInput.value.slice(-2); });
        mobileInput.addEventListener('keydown', (e) => { if (e.key === 'Backspace') updateText('Backspace'); });
        mobileInput.addEventListener('blur', () => { keyboardToggle.textContent = 'Keyboard'; keyboardVisible = false; });
        mobileInput.addEventListener('focus', () => { keyboardToggle.textContent = 'Hide'; keyboardVisible = true; });
        modeButtons.forEach(btn => btn.addEventListener('click', (e) => { e.preventDefault(); setMode(parseInt(btn.dataset.mode)); }));

        // Touch/Mouse event listeners for tracing (only active if isMobile)
        traceCanvas.addEventListener('touchstart', (e) => { e.preventDefault(); const touch = e.touches[0]; handleTraceStart(touch.clientX, touch.clientY); }, { passive: false });
        traceCanvas.addEventListener('touchmove', (e) => { e.preventDefault(); const touch = e.touches[0]; handleTraceMove(touch.clientX, touch.clientY); }, { passive: false });
        traceCanvas.addEventListener('touchend', (e) => { e.preventDefault(); handleTraceEnd(); }, { passive: false });
        traceCanvas.addEventListener('touchcancel', () => handleTraceEnd());
        traceCanvas.addEventListener('mousedown', (e) => handleTraceStart(e.clientX, e.clientY));
        traceCanvas.addEventListener('mousemove', (e) => handleTraceMove(e.clientX, e.clientY));
        traceCanvas.addEventListener('mouseup', () => handleTraceEnd());
        traceCanvas.addEventListener('mouseleave', () => handleTraceEnd());


        document.addEventListener('contextmenu', e => e.preventDefault());

        window.addEventListener('resize', resize);
        // Initial setup calls
        shuffleLetters();
        resize();
        detectMobile();
        setMode(1);
        animate();
    </script>
</body>

</html>